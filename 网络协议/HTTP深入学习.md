说到HTTP一个系统性了解还是去年看了些《HTTP权威指南》，本篇文章主要是复习一下HTTP相关知识，也是回忆自己看这本书大部分的能记忆下来的，权当是笔记吧。当然也是某个笔试题的总结。

## HTTP概述

首先了解HTTP协议得先知道HTTP报文结构，其中包括请求报文、返回报文：

请求报文包含四部分：

- 请求行：包含请求方法、URI、HTTP版本信息
- 请求首部字段
- 请求内容实体
- 空行

响应报文包含四部分：

- 状态行：包含HTTP版本、状态码、状态码的原因短语
- 响应首部字段
- 响应内容实体
- 空行

常见的首部：

- **通用首部字段（请求报文与响应报文都会使用的首部字段）**
  - Date：创建报文时间
  - Connection：连接的管理
  - Cache-Control：缓存的控制
  - Transfer-Encoding：报文主体的传输编码方式
- **请求首部字段（请求报文会使用的首部字段）**
  - Host：请求资源所在服务器
  - Accept：可处理的媒体类型
  - Accept-Charset：可接收的字符集
  - Accept-Encoding：可接受的内容编码
  - Accept-Language：可接受的自然语言
- **响应首部字段（响应报文会使用的首部字段）**
  - Accept-Ranges：可接受的字节范围
  - Location：令客户端重新定向到的URI
  - Server：HTTP服务器的安装信息
- **实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）**
  - Allow：资源可支持的HTTP方法
  - Content-Type：实体主类的类型
  - Content-Encoding：实体主体适用的编码方式
  - Content-Language：实体主体的自然语言
  - Content-Length：实体主体的的字节数
  - Content-Range：实体主体的位置范围，一般用于发出部分请求时使用

当然你也得区分URI 统一资源标识符（Uniform Resource Identifier）、URL 统一资源定位符、URN 统一资源名；

**URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。**

- Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的
- URI一般由三部组成：
- ①访问资源的命名机制
- ②存放资源的主机名
- ③资源自身的名称，由路径表示，着重强调于资源。

**URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。**

URL通用格式：

`<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>`



- URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。
- 采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：
- ①协议(或称为服务方式)
- ②存有该资源的主机IP地址(有时也包括端口号)
- ③主机资源的具体地址。如目录和文件名等

**URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。**

- URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。

HTTP 事物组成，包括 请求方法、返回状态码；你还得知道请求报文、返回报文 结构的相同性及不同性；

常见的HTTP状态码，状态码 分五种类型：信息性-1开头、成功-2开头、重定向-3开头、客户端错误-4开头、服务器错误-5开头。

- 200：请求被正常处理
- 204：请求被受理但没有资源可以返回
- 206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
- 301：永久性重定向
- 302：临时重定向
- 303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
- 304：发送附带条件的请求时，条件不满足时返回，与重定向无关
- 307：临时重定向，与302类似，只是强制要求使用POST方法
- 400：请求报文语法有误，服务器无法识别
- 401：请求需要认证
- 403：请求的对应资源禁止被访问
- 404：服务器无法找到对应资源
- 500：服务器内部错误
- 503：服务器正忙

接下来我们就可以看看HTTP是怎么连接的，这里就涉及到网络模型 各个层协议得作用，HTTP 协议处于应用层，使用传输层 TCP作为网络传输，大家有兴趣可以理解下[TCP与UDP](./TCP和UDP 总结.md)，TCP会调用网络层的IP 协议进行TCP数据分组传输，在此期间 TCP保证了稳定的数据传输、按序传输、分段数据流，你知道这些，你肯定会被问到  浏览器访问HTTP网站的整个流程；

<br>

##HTTP协议版本了解

接下来可能需要一些衍生了解HTTP协议版本，是如何从HTTP 0.9 升到 现在的HTTP 2.0，我们现在大多数使用的是HTTP 1.1。

HTTP 0.9 作为当初推出的第一个版本，当然也会存在非常多的Bug 缺陷，在这个版本只支持GET 请求，不支持多媒体内容MIME类型、各种HTTP首部、版本号，当时的目的 只是获取简单的HTML对象。

HTTP 1.0 在HTTP 0.9 基础上 加了HTTP 版本，各种HTTP 首部、一些额外的请求方法、多媒体类型支持。还有就是发送一次请求时，需要**等待服务端响应了**才可以继续发送请求。

HTTP 1.0+ 这是一种非正式的HTTP 1.0 扩展版，加入比较多的特性，如持久化链接、虚拟主机支持、代理。

HTTP 1.1 这个版本大家可能比较熟悉，就是我们平常在使用，这个版本重点是校正HTTP 设计中的结构性缺陷，明确语义，还有一部分性能优化措施 如默认开启持久化链接、Host 首部字段、Chunked transfer-coding 断点续传，也优化了不好用的特性。还有就是发送一次请求时，不需要等待服务端响应了就可以发送请求了，但是回送数据给客户端的时候，客户端还是需要按照**响应的顺序**来一一接收

- **持久连接**
- 请求管道化
- 增加缓存处理（新的字段如cache-control）
- 增加Host字段、支持断点传输等

HTTP 2.0 主要的是性能大幅度优化，更强大的服务逻辑远程执行框架。加入了管线化pipelining链接。

> HTTP Pipelining其实是把多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应；只不过，**客户端还是要按照发送请求的顺序来接收响应！**

管线化pipelining链接 理论主要是解决了线头阻塞的问题！其中最重要的改动是：多路复用 (Multiplexing)

线头阻塞 是因为返回结果 在前面HTTP协议中是按序接受的，多路复用意味着线头阻塞将不在是一个问题，允许同时通过单一的 HTTP/2 连接发起**多重的请求-响应消息**，合并多个请求为一个的优化将不再适用。

我在网上找了个图 可以直接说明 HTTP 2是如何进行性能优化的。

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef547ad1464?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

HTTP2所有性能增强的核心在于**新的二进制分帧层**(不再以文本格式来传输了)，它定义了如何封装http消息并在客户端与服务器之间传输。

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef59a266e62?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

看上去协议的格式和HTTP1.x完全不同了，**实际上HTTP2并没有改变HTTP1.x的语义**，只是把原来HTTP1.x的header和body部分用**frame重新封装了一层**而已

![img](https://user-gold-cdn.xitu.io/2018/7/30/164eaef56ba56ba1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

HTTP2连接上**传输的每个帧都关联到一个“流”**。流是一个独立的，双向的帧序列可以通过一个HTTP2的连接在服务端与客户端之间不断的交换数据。

HTTP2还有一些比较重要的改动：

- 使用HPACK对HTTP/2头部压缩
- 服务器推送
  - HTTP2推送资料：[segmentfault.com/a/119000001…](https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000015773338)
- 流量控制
  - 针对传输中的**流**进行控制(TCP默认的粒度是针对连接)
- 流优先级（Stream Priority）它被用来告诉**对端哪个流更重要**。
- 二进制分帧
- **多路复用**
- 头部压缩
- 服务器推送

在这里不讲[HTTPS协议](./HTTPS深入理解.md)

<br>

## HTTP连接管理

说到HTTP连接，实际上就是TCP连接和一些使用连接的规则。TCP在传输层上来说是个可靠连接协议。

首先TCP会为HTTP提供一条可靠的比特传输管道，从TCP连接一端填入的字节会从另外一端以原有的顺序、正确地传送出来；TCP的数据流会先进行分段，通过IP分组的小数据块发送的，每个TCP段都是由IP分组承载，从一个IP到地址发送到另外一个IP的。那么每个IP分组都包括：

- IP分组首部——通常20字节，包含 源和目的IP地址、长度和一些标识、分组ID、
- TCP段首部——通常20字节，包含了TCP 源和目的 端口号、TCP控制标记，及用于数据排序和完整性检查的一些数字值、窗口尺寸、保留字（ack、urg、psh、syn、fin、rst）
- TCP数据块——0+个字节

那么浏览器从输入地址到返回结果，这里发生了什么事情呢？

1. 首先解析出主机名
2. 查询出主机名的相对应IP地址 （DNS）
3. 浏览器获得端口号
4. 浏览器发起到目的IP端口的TCP连接
5. 浏览器向服务器发送HTTP METHOD 报文
6. 浏览器从服务器读取返回的报文
7. 浏览器关闭连接

以上是HTTP请求简化 是因为这里没涉及到HTTP、TCP一些特性(如TCP管道持久化等)，HTTP连接主要依赖TCP连接。

那么TCP是如何进行双方的连接呢？其实TCP连接步骤 有点像socket 套接字编程步骤：

- 服务端 S1（服务端用S表示、客户端用C表示，数字表示相对应端的步骤序号）创建新的套接字 socket
- S2将socket绑定到端口上 bind
- S3允许socket进行连接 listen
- S4 等待连接 accept
- C1 获取本地客户端 IP地址和端口号
- C2创建新的套接字 socket
- C3 连接到服务器 IP 端口 connect 
- S5 通知应用程序有连接到来
- S6开始读取请求 read
- C4 连接成功
- C5 发送HTTP 请求 write
- C6 等待HTTP响应 read
- S7处理HTTP请求报文
- S8回送HTTP响应 write
- C7 读取及处理HTTP响应
- S9关闭连接 close
- C8 关闭连接 close

在这里TCP请求流量 没体现出 TCP三次握手四次挥手，这是建立连接、及关闭连接的时候发生的。

### TCP性能分析

虽然HTTP是建立在TCP上，TCP也有一些性能优化方式。HTTP事务的性能在很大程度上取决于底层TCP通道的性能。

只有先理解TCP某些特性后，才能更好的理解HTTP连接优化特性。

最常见、会对HTTP产生影响的TCP相关时延：

- 建立握手
- 慢启动拥塞控制
- 数据聚集的Nagle算法
- 用于捎带确认的TCP延迟确认算法
- TIME_WAIT时延和端口耗尽

我们来分别来解释为什么会有以上这些时延，怎么发生的。

1、TCP连接的握手时延

TCP连接三次握手步骤：

- 客户端向服务器发送一个小的TCP分组（大约40至60字节），这个分组在IP协议中的TCP段里设置了一个特殊的保留字 SYN标记，说明这是一个连接请求；
- 如果服务器接受了连接，就会对一些连接参数进行计算，并向客户端回送一个TCP分组，这个分组中的保留字 的 SYN 和 ACK标记都被置位，说明连接请求已被接受
- 最后，客户端向服务器回送一条确认信息，通知它连接已经成功建立。不过现在的TCP栈都支持在这个消息带上数据体。

此时，SYN/SYN+ACK握手会产生一个可测量的时延。如果当前HTTP事物 需要的数据量较小的话，那么这TCP握手占用整个HTTP事务 比例多，那么现在HTTP如何通过重用现存的连接，来减少这种TCP建立时延。那就是HTTP持久化连接。

2、延时确认

因为因特网无法确保可靠的分组传输，所以TCP实现了自己的确认机制来确保数据的成功传输。

每个TCP段 的接受者 收到了完整的段时，都会向发送这回送小的确认分组，如果发送这没有在指定的窗口时间内收到确认信息，那发送者会认为该分组已被破坏损毁，及重新发送数据。

“延迟确认”算法会在一个特定的窗口时间（通常是100至200ms）内将输出确认存在在缓冲区中，以寻找能够捎带它输出的数据分组，如果那个时间段内没有输出数据分组，将单独的分组传送。

3、TCP慢启动

TCP数据传输的性能还取决于TCP连接的使用期。TCP连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种TCP慢启动，主要用于防止因特网的突然过载和拥塞。

TCP慢启动限制了一个TCP端点在任意时刻可以传输的分组数。简单来说，每成功接收一个分组，发送端就有了发送另外两个分组的权限。所以HTTP事务有大量数据、大量数组分组要发送，这是不可能一次将所有分组都发送出去的。这种方式称为“打开拥塞窗口”。

4、Nagle算法与TCP_NODELAY

TCP有一个数据流接口，应用程序可以通过它将任意尺寸的数据放入TCP栈中——即使一次只放一个字节。我们分析IP协议各个部分可以看出，每个TCP段都至少需要40+个字节的IP首部、TCP段首部，还有部分的内容（TCP数据块），如果数据块过少 就会导致网络性能严重下降。

Nagle算法就是试图在发送一个分组之前，将大量的TCP数据绑定在一起，以提供网络效率。该算法鼓励发送尺寸大约1500字节的段。只有当所有其他分组都被确认之后，Nagle算法 才会允许发送非全尺寸的分组。

这种算法会导致 小的HTTP报文无法填满一个分组，可能一直不会有其他额外数据产生时延；其次 该算法会与 延迟确认 之间存在交互问题，该算法会阻止数据的发送，直到有确认分组抵达为止，但确认分组自身会被延迟确认算法延迟。

5、TIME_WAIT累积与端口耗尽

TIME_WAIT 大家可能对这单词可能有点迷糊，这是socket连接不同时候的状态标识，在Linux 中可以 nstat 查看网络连接状态。大家可以从网上找socket连接图，我当时是从 《深入分析JavaWeb技术内幕——许令波》看到的。

当某个TCp端点关闭TCP连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号。这类信息只会生存一小段时间，通常是所估计得最大分段使用期的两倍 2MSL(约2分钟)左右，以确保在这段时间内不会创建相同地址和端口的新连接。

每个客户端每次连接到服务器时，都会获取一个新的窗口，以实现连接的唯一性（源和目的IP及端口），但是服务器的端口是有限的，而且在2MSL内无法重用，连接速率就会限制在60000/120=500次/秒。如果连接速率高于这个值，就会遇到TIME_WAIT端口耗尽问题，但修复这问题，可以增加集群机器数量，或者确保客户端和服务器在循环使用几个虚拟IP地址增加更多的理解组合。所以这TIME_WAIT 、控制块 大量连接处于这个状态，有些操作系统会受到严重的影响。

<br>

## HTTP连接处理

以上我们刚刚探讨了TCP连接及性能分析，那这里就引入HTTP是如何连接及分析。

- 串行连接

  该连接只是对连接简单的管理，TCP的性能时延（如慢启动时延、连接时延）可能会叠加起来。如果网页需要进渲染，就可能需要等待所有的网页对象，在这之前，页面可能是空白的。

- 并行连接

  并行发送多个TCP连接，可能会受到网络带宽影响，每次连接对象会去抢带宽资源，达到带宽上限就会每个连接对象的带宽都会下降。而且多个连接对象会消耗很多内存资源，引发自身性能问题。

- 持久连接

  重用TCP连接，可以消除**连接及关闭时延**。在HTTP 1.1时，请求首部默认 保持持久化连接，重用对目标服务器打开的空闲持久连接，可以避开缓慢的建立阶段，也会避免慢启动的拥塞阶段。不过请求首部 Keep-Alive字段 需要注意使用代理从而出现哑代理。如果代理不进行首部 头部字段处理，那么会导致盲中继问题。这样会导致只能等待连接关闭。导致客户端再进行发起同一条请求（持久化连接可以理解为另外一条请求就是同一条请求），然而代理并不认为是同一条（比如不支持持久化连接），就会丢弃该连接。

  这种问题 可以使用首部 Proxy-Connection 字段。

- 管道化连接

  管道化在HTTP 1.1就提出并有一定的操作，但是在HTTP 2.0用的比较成熟。

  管道化连接 消除了**传输时延**。在进行多个事务时候，管道化连接以一种非阻塞方式（有点像双工通信方式） 并行发送请求（但不是打开多个连接，只有一个），可以说是一个连接获取到 并行连接的效果，但不存在 并行连接的缺点。

<br>

## web服务器会做什么

在这里讨论web服务器一般对整个HTTP请求到响应的整个过程的动作。

1. 建立连接

   接受一个客户端连接，或者如果不希望与这个客户端建立连接，就将其关闭

2. 接受请求

   从网络中读取一条HTTP请求报文

3. 处理请求

   对请求报文进行解释，并采取行动

4. 访问资源

   ​

5. 构建响应

   ​

6. 发送响应

   ​

7. 记录事务处理过程

   ​



















